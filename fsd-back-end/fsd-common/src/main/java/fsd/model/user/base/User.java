package fsd.model.user.base;

import java.util.Date;
import java.util.Objects;

import javax.persistence.Column;
import javax.persistence.EntityListeners;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.MappedSuperclass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.NotNull;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonIgnore;

import org.hibernate.annotations.GenericGenerator;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@MappedSuperclass
@Getter
@Setter
@NoArgsConstructor
@EntityListeners(AuditingEntityListener.class) // automaticlly complete created time and updated time
//@GenericGenerator(name = "idGenerator", strategy = "org.hibernate.id.UUIDGenerator" )
public class User {

    /**
     * User id which is generated by database
     */
    @Id
    @Column(name = "ID", length = 64)
    // @GeneratedValue(strategy = GenerationType.IDENTITY) // auto increase
    // @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "userSeq")
    // @SequenceGenerator(name = "userSeq", sequenceName = "BUYER_SEQ",
    // allocationSize = 1)
    @GenericGenerator(name = "idGenerator", strategy = "uuid2")
    @GeneratedValue(generator = "idGenerator")
    private String id;

    /**
     * Login User name
     */
    @Column(name = "USERNAME", unique = true, columnDefinition = "varchar(30) not null comment 'user login name'")
    @NotNull
    private String username;

    /**
     * Password
     * <p>
     * encrpted by BCryptPasswordEncoder
     * </p>
     */
    @Column(name = "PASSWORD", columnDefinition = "varchar(64) not null comment 'user password'")
    //@JsonIgnore // Ignore this field when generate to Json
    private String password;

    // @Column(length = 200)
    // @JsonIgnore
    // private String salt;

    /**
     * Email address
     */
    @Column(name = "EMAIL", columnDefinition = "varchar(50) not null comment 'email id'")
    @NotBlank
    private String email;

    /**
     * Expired date
     */
    @Column(name = "EXPIRE_DATE", columnDefinition = "datetime not null comment 'password expired date'")
    @Temporal(TemporalType.TIMESTAMP)
    //@JsonIgnore // Ignore this field when generate to Json
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss")
    private Date expireDate;

    /**
     * User enable flag
     * <ul>
     * <li>0: Normal
     * <li>1: User is locked
     * <li>2: User is disabled
     * </ul>
     */
    @Column(name = "STATUS", columnDefinition="char(1) not null default '0' comment 'Normal:0 / Locked:1 / Disabled: 2'")
    //@JsonIgnore // Ignore this field when generate to Json
    private String status;

    /**
     * Created time
     */
    @CreatedDate
    @Column(name = "created_date", updatable = false)
    @JsonIgnore // Ignore this field when generate to Json
    private Date created;

    /**
     * Updated time
     */
    @LastModifiedDate
    @Column(name = "updated_date")
    //@JsonIgnore // Ignore this field when generate to Json
    @JsonFormat(pattern="yyyy-MM-dd HH:mm:ss")
    private Date updated;


    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        User that = (User) o;
        return Objects.equals(id, that.id) && Objects.equals(username, that.username)
                && Objects.equals(password, that.password) && Objects.equals(email, that.email)
                && Objects.equals(expireDate, that.expireDate) && Objects.equals(status, that.status)
                && Objects.equals(created, that.created) && Objects.equals(updated, that.updated);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, username, password, email, expireDate, status, created, updated);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("User {").append("id = '").append(id).append("'").append("username = '").append(username).append("'")
                .append("password = '").append(password).append("'").append("email = '").append(email).append("'")
                .append("expireDate = '").append(expireDate).append("'").append("status = '").append(status).append("'")
                .append("created = '").append(created).append("'").append("updated = '").append(updated).append("'")
                .append("}");
        return sb.toString();
    }
}